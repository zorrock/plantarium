var R=Object.defineProperty;var E=Object.getOwnPropertySymbols;var z=Object.prototype.hasOwnProperty,O=Object.prototype.propertyIsEnumerable;var F=(e,r,t)=>r in e?R(e,r,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[r]=t,w=(e,r)=>{for(var t in r||(r={}))z.call(r,t)&&F(e,t,r[t]);if(E)for(var t of E(r))O.call(r,t)&&F(e,t,r[t]);return e};import{n as k,a as v,j as G,t as T,c as V}from"./index-b73a3247.js";import"./index-d3daae02.js";import"./singletons-d04dcdd1.js";function q(e,r=[0,0,0],t=[0,0,0],a=[1,1,1]){const c=new Float32Array(e.position.length),f=e.position.length,d=e.position;for(let s=0;s<f;s+=3){const h=d[s+0]*a[0],g=d[s+1]*a[1],N=d[s+2]*a[2],n=h,o=Math.cos(t[0])*g-Math.sin(t[0])*N,i=Math.sin(t[0])*g+Math.cos(t[0])*N,p=Math.cos(t[1])*n-Math.sin(t[1])*i,u=o,m=Math.sin(t[1])*n+Math.cos(t[1])*i;c[s+0]=p+r[0],c[s+1]=u+r[1],c[s+2]=m+r[2]}return{position:c,uv:e.uv,normal:e.normal,index:e.index}}function P(e){if(Array.isArray(e))return e.map(s=>P(s)).flat();const r=[],t={position:e.position,normal:e.normal,uv:e.uv,index:e.index},a=e.offset,c=e.rotation,f=e.scale,d=e.offset.length;for(let s=0;s<d;s+=3)r.push(q(t,[a[s+0],a[s+1],a[s+2]],[c[s+0],c[s+1],c[s+2]],[f[s+0],f[s+1],f[s+2]]));return r}const x=e=>{console.groupCollapsed(e),console.trace(),console.groupEnd()};function I(e,r=!1){const t=e.normal.includes(NaN);t&&x("Normals has NaN");const a=e.index.includes(NaN);a&&x("Index has NaN");const c=e.position.includes(NaN);c&&x("Position has NaN");const f=e.uv.includes(NaN);f&&x("UV has NaN");const d=e.position.length/3;e.position.length!==e.normal.length&&x("position and normal amount not eqal"),e.uv.length!==d*2&&x("uv amount not correct, should be "+d*2+" is "+e.uv.length),(t||a||c||f||r)&&console.log("Check",{p:e.position.length,pn:c,n:e.normal.length,nn:t,i:e.index.length,in:a,u:e.uv.length,un:f})}let B="",S,C=2;const U=e=>{let r=0;return k.seed=0,{_id:"",getId(){return this._id},n1d(t){return k.n1d(C++*t)},n1dn(t){return 1+k.n1d(C++*t)/2},getSetting(t){return e[t]},get settings(){return e},get seed(){return r},refresh(){C=2,e!=null&&e.useRandomSeed&&(r=Math.floor(Math.random()*1e5),k.seed=r)}}};var D=e=>{const r=JSON.stringify(e);return r!==B&&(B=r,S=U(e)),S.refresh(),S};function J({nodes:e},r){const t=D(r),a=new Map,c=new Map,f=n=>{var o;return(o=c.get(n))!=null?o:[]},d=n=>{var o;return(o=a.get(n))!=null?o:[]};let s=[];for(const{attributes:n,state:o}of e){const i=v.get(n.type);if(!i)return console.log("Existing node types: ",{nodeMap:v}),{errors:["Missing NodeType "+n.type]};s.push({attributes:n,state:o,exec:i,type:n.type,id:n.id,level:-1,results:[]})}let h;if(s.forEach(n=>{a.set(n.id,n),!h&&n.type==="output"&&(h=n,h.level=0),n.attributes.refs.forEach(o=>{c.has(o.id)?c.set(o.id,[...c.get(o.id),{n,in:o.in,out:o.out}]):c.set(o.id,[{n,in:o.in,out:o.out}])})}),!h)return{errors:["Missing output node"]};function g(n){if(n!=null&&n.buckets)return n.buckets;let o=[n],i=[n];for(;o.length;){const u=o.shift(),m=f(u.id);if(m!=null&&m.length)for(const{n:y}of m)y.level=u.level+1,i.includes(y)||i.push(y),o.push(y)}const p=[];for(const u of i)p[u.level]?p[u.level].push(u):p[u.level]=[u];return n.buckets=p,p}function N(n){var p,u,m,y;if("parameters"in n)return n.parameters;let o={};const i=v.get(n.type);for(const l of f(n.id)){const _=l.n;_.exec.outputs[0]==="plant"?o[l.in]=()=>l.n.results[0]:(p=_.exec)!=null&&p.computeValue?o[l.in]=(b=1)=>{const M=N(l.n);return _.exec.computeValue(M,t,b)}:o[l.in]=(b=1)=>{const M={},A=N(l.n);return Object.keys(A).forEach(j=>{M[j]=A[j](b)}),M}}for(const l of Object.keys(i.parameters))if((u=i.parameters[l])!=null&&u.internal)o[l]=n.state[l];else if(o[l]===void 0){if((m=i.parameters[l])!=null&&m.required&&o[l]===void 0)return{errors:["Missing Input ["+(((y=i.parameters[l])==null?void 0:y.label)||l)+"] in "+i.type]};o[l]=()=>n.state[l]}return n.parameters=o,o}return{nodes:s,outputNode:h,getNodeRef:f,getNode:d,getBucketsForNode:g,constructParametersForNode:N,ctx:t}}async function Q(e,r){var g,N;const t=J(e,r);if(t.errors)return{errors:t.errors};const a=t.ctx,c=t.getBucketsForNode(t.outputNode);for(const n of c.reverse())for(const o of n){const i=v.get(o.type);if(i){let p=t.constructParametersForNode(o);if(p!=null&&p.errors)return{errors:p.errors};if(i!=null&&i.computeStem){a._id=o.id;const u=i.computeStem(p,a);u.stems.find(m=>m.skeleton.includes(NaN))&&(console.warn("Node "+i.type+" produced NaN in skeleton"),console.log({result:u})),o.results=Array.isArray(u)?u:[u]}if(i!=null&&i.computeGeometry){const u=i.computeGeometry(p,o.results[0],a);o.results[0]=w(w({},o.results[0]),u)}}else console.warn("Missing Type",o.type),console.log(v)}if(!((N=(g=t==null?void 0:t.outputNode)==null?void 0:g.parameters)!=null&&N.input))return{errors:["Missing input connection to output node"]};const f=t.outputNode.parameters.input();if(!f)return{errors:["DUnno?"]};const{stems:d,instances:s}=f;let h=G(...d.map(n=>T(n.skeleton,a.getSetting("stemResX"))));if(s){I(h);const n=s==null?void 0:s.map(o=>P(o)).flat();h=G(h,...n),I(h)}return{stems:d,geometry:V(h)}}export{Q as executeNodeSystem};
